import schedule
import time
import threading
import logging
import json
from datetime import datetime, timedelta, time as dt_time
from typing import Dict, Optional
import sqlite3
from ai_analysis import AIAnalysisEngine

class AutoStoreManager:
    def __init__(self, db_path='pos_database.db'):
        self.logger = logging.getLogger(__name__)
        self.db_path = db_path
        self.ai_engine = AIAnalysisEngine(db_path)
        self.auto_close_settings = {}
        self.scheduler_running = False
        self.scheduler_thread = None
        
    def start_scheduler(self):
        """р╣Ар╕гр╕┤р╣Ир╕бр╕Хр╣Йр╕Щ scheduler р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Бр╕▓р╕гр╕Ыр╕┤р╕Фр╕гр╣Йр╕▓р╕Щр╕нр╕▒р╕Хр╣Вр╕Щр╕бр╕▒р╕Хр╕┤"""
        if not self.scheduler_running:
            self.scheduler_running = True
            self.scheduler_thread = threading.Thread(target=self._run_scheduler, daemon=True)
            self.scheduler_thread.start()
            self.logger.info("Auto store close scheduler started")
    
    def stop_scheduler(self):
        """р╕лр╕вр╕╕р╕Ф scheduler"""
        self.scheduler_running = False
        if self.scheduler_thread:
            self.scheduler_thread.join()
        self.logger.info("Auto store close scheduler stopped")
    
    def _run_scheduler(self):
        """р╕гр╕▒р╕Щ scheduler р╣Гр╕Щр╕Юр╕╖р╣Йр╕Щр╕лр╕ер╕▒р╕З"""
        while self.scheduler_running:
            schedule.run_pending()
            time.sleep(60)  # р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Чр╕╕р╕Бр╕Щр╕▓р╕Чр╕╡
    
    def set_auto_close_time(self, store_id: int, close_time: str, enabled: bool = True) -> bool:
        """р╕Хр╕▒р╣Йр╕Зр╣Ар╕зр╕ер╕▓р╕Ыр╕┤р╕Фр╕гр╣Йр╕▓р╕Щр╕нр╕▒р╕Хр╣Вр╕Щр╕бр╕▒р╕Хр╕┤"""
        try:
            # р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕гр╕╣р╕Ыр╣Бр╕Ър╕Ър╣Ар╕зр╕ер╕▓ (HH:MM)
            try:
                close_time_obj = datetime.strptime(close_time, '%H:%M').time()
            except ValueError:
                self.logger.error(f"Invalid time format: {close_time}")
                return False
            
            # р╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕Бр╕▓р╕гр╕Хр╕▒р╣Йр╕Зр╕Др╣Ир╕▓
            self.auto_close_settings[store_id] = {
                'close_time': close_time,
                'enabled': enabled,
                'updated_at': datetime.now().isoformat()
            }
            
            # р╕ер╕Ъ job р╣Ар╕Бр╣Ир╕▓
            schedule.clear(f'auto_close_{store_id}')
            
            # р╣Ар╕Юр╕┤р╣Ир╕б job р╣Гр╕лр╕бр╣И
            if enabled:
                schedule.every().day.at(close_time).do(
                    self._auto_close_store, store_id
                ).tag(f'auto_close_{store_id}')
                
                self.logger.info(f"Auto close scheduled for store {store_id} at {close_time}")
            
            # р╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕ер╕Зр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕е
            self._save_auto_close_setting(store_id, close_time, enabled)
            
            return True
            
        except Exception as e:
            self.logger.error(f"Error setting auto close time: {e}")
            return False
    
    def _auto_close_store(self, store_id: int):
        """р╕Ыр╕┤р╕Фр╕гр╣Йр╕▓р╕Щр╕нр╕▒р╕Хр╣Вр╕Щр╕бр╕▒р╕Хр╕┤"""
        try:
            # р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕зр╣Ир╕▓р╕гр╣Йр╕▓р╕Щр╣Ар╕Ыр╕┤р╕Фр╕нр╕вр╕╣р╣Ир╕лр╕гр╕╖р╕нр╣Др╕бр╣И
            if not self._is_store_open(store_id):
                self.logger.info(f"Store {store_id} is already closed")
                return
            
            # р╕кр╕гр╣Йр╕▓р╕Зр╕кр╕гр╕╕р╕Ыр╕вр╕нр╕Фр╕Вр╕▓р╕вр╕Бр╣Ир╕нр╕Щр╕Ыр╕┤р╕Фр╕гр╣Йр╕▓р╕Щ
            daily_summary = self.generate_daily_summary(store_id)
            
            # р╕Ыр╕┤р╕Фр╕гр╣Йр╕▓р╕Щ
            success = self._close_store(store_id, auto_close=True)
            
            if success:
                self.logger.info(f"Store {store_id} automatically closed at {datetime.now()}")
                
                # р╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕кр╕гр╕╕р╕Ыр╕вр╕нр╕Фр╕Вр╕▓р╕в
                self._save_daily_summary(store_id, daily_summary)
            else:
                self.logger.error(f"Failed to auto close store {store_id}")
                
        except Exception as e:
            self.logger.error(f"Error in auto close store {store_id}: {e}")
    
    def generate_daily_summary(self, store_id: int, target_date: str = None) -> Dict:
        """р╕кр╕гр╣Йр╕▓р╕Зр╕кр╕гр╕╕р╕Ыр╕вр╕нр╕Фр╕Вр╕▓р╕вр╕гр╕▓р╕вр╕зр╕▒р╕Щ"""
        try:
            if target_date is None:
                target_date = datetime.now().date()
            else:
                target_date = datetime.fromisoformat(target_date).date()
            
            # р╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕вр╕нр╕Фр╕Вр╕▓р╕вр╕зр╕▒р╕Щр╕Щр╕╡р╣Й
            daily_analysis = self.ai_engine.analyze_daily_sales(target_date)
            
            # р╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Ар╕бр╕Щр╕╣р╕Вр╕▓р╕вр╕Фр╕╡
            menu_analysis = self.ai_engine.analyze_menu_performance(1)  # р╕зр╕▒р╕Щр╕Щр╕╡р╣Йр╣Ар╕Чр╣Ир╕▓р╕Щр╕▒р╣Йр╕Щ
            
            # р╕Фр╕╢р╕Зр╕Др╕│р╣Бр╕Щр╕░р╕Щр╕│р╕зр╕▒р╕Хр╕Цр╕╕р╕Фр╕┤р╕Ър╕кр╕│р╕лр╕гр╕▒р╕Ър╕Юр╕гр╕╕р╣Ир╕Зр╕Щр╕╡р╣Й
            ingredient_recommendations = self.ai_engine.predict_ingredient_needs(1)
            
            # р╕кр╕гр╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕нр╕зр╕вр╕Юр╕гр╣Бр╕ер╕░р╕Др╕│р╣Бр╕Щр╕░р╕Щр╕│
            blessing_message = self._generate_blessing_message()
            ai_recommendations = self._generate_ai_recommendations(daily_analysis, menu_analysis, ingredient_recommendations)
            
            summary = {
                'store_id': store_id,
                'date': target_date.isoformat(),
                'daily_analysis': daily_analysis,
                'menu_analysis': menu_analysis,
                'ingredient_recommendations': ingredient_recommendations,
                'blessing_message': blessing_message,
                'ai_recommendations': ai_recommendations,
                'generated_at': datetime.now().isoformat()
            }
            
            return summary
            
        except Exception as e:
            self.logger.error(f"Error generating daily summary: {e}")
            return {}
    
    def generate_opening_summary(self, store_id: int) -> Dict:
        """р╕кр╕гр╣Йр╕▓р╕Зр╕кр╕гр╕╕р╕Ыр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Ар╕бр╕╖р╣Ир╕нр╣Ар╕Ыр╕┤р╕Фр╕гр╣Йр╕▓р╕Щ"""
        try:
            # р╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕нр╕зр╕вр╕Юр╕гр╣Ар╕Ыр╕┤р╕Фр╕гр╣Йр╕▓р╕Щ
            opening_message = self._generate_opening_message()
            
            # р╕Фр╕╢р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕вр╕нр╕Фр╕Вр╕▓р╕вр╣Ар╕бр╕╖р╣Ир╕нр╕зр╕▓р╕Щ
            yesterday = datetime.now().date() - timedelta(days=1)
            yesterday_analysis = self.ai_engine.analyze_daily_sales(yesterday)
            
            # р╕Др╕│р╣Бр╕Щр╕░р╕Щр╕│р╕кр╕│р╕лр╕гр╕▒р╕Ър╕зр╕▒р╕Щр╕Щр╕╡р╣Й
            today_recommendations = self._generate_today_recommendations(yesterday_analysis)
            
            summary = {
                'store_id': store_id,
                'date': datetime.now().date().isoformat(),
                'opening_message': opening_message,
                'yesterday_analysis': yesterday_analysis,
                'today_recommendations': today_recommendations,
                'generated_at': datetime.now().isoformat()
            }
            
            return summary
            
        except Exception as e:
            self.logger.error(f"Error generating opening summary: {e}")
            return {}
    
    def _generate_blessing_message(self) -> str:
        """р╕кр╕гр╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕нр╕зр╕вр╕Юр╕гр╕Ыр╕┤р╕Фр╕гр╣Йр╕▓р╕Щ"""
        messages = [
            "ЁЯМЯ р╕Вр╕нр╕Ър╕Др╕╕р╕Ур╕кр╕│р╕лр╕гр╕▒р╕Ър╕Бр╕▓р╕гр╕Чр╕│р╕Зр╕▓р╕Щр╕лр╕Щр╕▒р╕Бр╕зр╕▒р╕Щр╕Щр╕╡р╣Й! р╕Юр╕гр╕╕р╣Ир╕Зр╕Щр╕╡р╣Йр╕Ир╕░р╣Ар╕Ыр╣Зр╕Щр╕зр╕▒р╕Щр╕Чр╕╡р╣Ир╕Фр╕╡р╕Бр╕зр╣Ир╕▓р╕Щр╕╡р╣Й",
            "ЁЯТк р╕зр╕▒р╕Щр╕Щр╕╡р╣Йр╕Ьр╣Ир╕▓р╕Щр╣Др╕Ыр╕Фр╣Йр╕зр╕вр╕Фр╕╡ р╕Вр╕нр╣Гр╕лр╣Йр╕Юр╕▒р╕Бр╕Ьр╣Ир╕нр╕Щр╣Гр╕лр╣Йр╣Ар╕Юр╕╡р╕вр╕Зр╕Юр╕н р╣Бр╕ер╣Йр╕зр╕Юр╕Ър╕Бр╕▒р╕Щр╣Гр╕лр╕бр╣Ир╕Юр╕гр╕╕р╣Ир╕Зр╕Щр╕╡р╣Й",
            "ЁЯЩП р╕Вр╕нр╕Ър╕Др╕╕р╕Ур╕Чр╕╡р╣Ир╣Гр╕лр╣Йр╕Ър╕гр╕┤р╕Бр╕▓р╕гр╕ер╕╣р╕Бр╕Др╣Йр╕▓р╕Фр╣Йр╕зр╕вр╣Гр╕И р╕зр╕▒р╕Щр╕Щр╕╡р╣Йр╣Ар╕Ыр╣Зр╕Щр╕нр╕╡р╕Бр╕зр╕▒р╕Щр╕Чр╕╡р╣Ир╕Ыр╕гр╕░р╕кр╕Ър╕Др╕зр╕▓р╕бр╕кр╕│р╣Ар╕гр╣Зр╕И",
            "тЬи р╕Бр╕▓р╕гр╕Чр╕│р╕Зр╕▓р╕Щр╕лр╕Щр╕▒р╕Бр╕Вр╕нр╕Зр╕зр╕▒р╕Щр╕Щр╕╡р╣Йр╕Ир╕░р╕Щр╕│р╕бр╕▓р╕Лр╕╢р╣Ир╕Зр╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣Мр╕Чр╕╡р╣Ир╕Фр╕╡р╣Гр╕Щр╕нр╕Щр╕▓р╕Др╕Х",
            "ЁЯМЩ р╕Вр╕нр╣Гр╕лр╣Йр╕бр╕╡р╕Др╕зр╕▓р╕бр╕кр╕╕р╕Вр╕Бр╕▒р╕Ър╕Бр╕▓р╕гр╕Юр╕▒р╕Бр╕Ьр╣Ир╕нр╕Щ р╣Бр╕ер╕░р╕Хр╕╖р╣Ир╕Щр╕бр╕▓р╕Юр╕гр╣Йр╕нр╕бр╕Юр╕ер╕▒р╕Зр╣Гр╕лр╕бр╣Ир╕Юр╕гр╕╕р╣Ир╕Зр╕Щр╕╡р╣Й"
        ]
        
        import random
        return random.choice(messages)
    
    def _generate_opening_message(self) -> str:
        """р╕кр╕гр╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕нр╕зр╕вр╕Юр╕гр╣Ар╕Ыр╕┤р╕Фр╕гр╣Йр╕▓р╕Щ"""
        weekday = datetime.now().weekday()
        day_names = ['р╕Ир╕▒р╕Щр╕Чр╕гр╣М', 'р╕нр╕▒р╕Зр╕Др╕▓р╕г', 'р╕Юр╕╕р╕Ш', 'р╕Юр╕др╕лр╕▒р╕кр╕Ър╕Фр╕╡', 'р╕ир╕╕р╕Бр╕гр╣М', 'р╣Ар╕кр╕▓р╕гр╣М', 'р╕нр╕▓р╕Чр╕┤р╕Хр╕вр╣М']
        
        messages = [
            f"ЁЯМЕ р╕кр╕зр╕▒р╕кр╕Фр╕╡р╕Хр╕нр╕Щр╣Ар╕Кр╣Йр╕▓! р╕Вр╕нр╣Гр╕лр╣Йр╕зр╕▒р╕Щ{day_names[weekday]}р╕Щр╕╡р╣Йр╣Ар╕Ыр╣Зр╕Щр╕зр╕▒р╕Щр╕Чр╕╡р╣Ир╕Фр╕╡р╣Бр╕ер╕░р╕Ыр╕гр╕░р╕кр╕Ър╕Др╕зр╕▓р╕бр╕кр╕│р╣Ар╕гр╣Зр╕И",
            f"тШАя╕П р╣Ар╕гр╕┤р╣Ир╕бр╕Хр╣Йр╕Щр╕зр╕▒р╕Щ{day_names[weekday]}р╕Фр╣Йр╕зр╕вр╕Юр╕ер╕▒р╕Зр╕Ър╕зр╕Б р╕Вр╕нр╣Гр╕лр╣Йр╕бр╕╡р╕ер╕╣р╕Бр╕Др╣Йр╕▓р╣Ар╕вр╕нр╕░р╣Ж р╕зр╕▒р╕Щр╕Щр╕╡р╣Й",
            f"ЁЯОп р╕зр╕▒р╕Щ{day_names[weekday]}р╣Гр╕лр╕бр╣Ир╕бр╕▓р╕Цр╕╢р╕Зр╣Бр╕ер╣Йр╕з! р╕Юр╕гр╣Йр╕нр╕бр╕Чр╕╡р╣Ир╕Ир╕░р╕кр╕гр╣Йр╕▓р╕Зр╕вр╕нр╕Фр╕Вр╕▓р╕вр╕Чр╕╡р╣Ир╕Фр╕╡р╕Бр╕▒р╕Щр╣Др╕лр╕б",
            f"ЁЯТл р╕Вр╕нр╣Гр╕лр╣Йр╕зр╕▒р╕Щ{day_names[weekday]}р╕Щр╕╡р╣Йр╣Ар╕Хр╣Зр╕бр╣Др╕Ыр╕Фр╣Йр╕зр╕вр╣Вр╕нр╕Бр╕▓р╕кр╕Фр╕╡р╣Ж р╣Бр╕ер╕░р╕Др╕зр╕▓р╕бр╕кр╕│р╣Ар╕гр╣Зр╕И",
            f"ЁЯЪА р╣Ар╕гр╕┤р╣Ир╕бр╕Хр╣Йр╕Щр╕зр╕▒р╕Щ{day_names[weekday]}р╕Фр╣Йр╕зр╕вр╕Др╕зр╕▓р╕бр╕бр╕╕р╣Ир╕Зр╕бр╕▒р╣Ир╕Щ р╕Вр╕нр╣Гр╕лр╣Йр╕Чр╕╕р╕Бр╕нр╕вр╣Ир╕▓р╕Зр╣Ар╕Ыр╣Зр╕Щр╣Др╕Ыр╕Хр╕▓р╕бр╕Чр╕╡р╣Ир╕лр╕зр╕▒р╕З"
        ]
        
        import random
        return random.choice(messages)
    
    def _generate_ai_recommendations(self, daily_analysis: Dict, menu_analysis: Dict, ingredient_recommendations: Dict) -> list:
        """р╕кр╕гр╣Йр╕▓р╕Зр╕Др╕│р╣Бр╕Щр╕░р╕Щр╕│ AI"""
        recommendations = []
        
        if daily_analysis:
            revenue = daily_analysis.get('total_revenue', 0)
            orders = daily_analysis.get('total_orders', 0)
            change = daily_analysis.get('revenue_change_percent', 0)
            
            if revenue > 0:
                recommendations.append(f"ЁЯУК р╕зр╕▒р╕Щр╕Щр╕╡р╣Йр╕вр╕нр╕Фр╕Вр╕▓р╕вр╕гр╕зр╕б {revenue:,.2f} р╕Ър╕▓р╕Ч р╕Ир╕▓р╕Бр╕нр╕нр╕гр╣Мр╣Ар╕Фр╕нр╕гр╣М {orders} р╕гр╕▓р╕вр╕Бр╕▓р╕г")
                
                if change > 5:
                    recommendations.append(f"ЁЯУИ р╕вр╕нр╕Фр╕Вр╕▓р╕вр╣Ар╕Юр╕┤р╣Ир╕бр╕Вр╕╢р╣Йр╕Щ {change:.1f}% р╣Ар╕бр╕╖р╣Ир╕нр╣Ар╕Чр╕╡р╕вр╕Ър╕Бр╕▒р╕Ър╣Ар╕бр╕╖р╣Ир╕нр╕зр╕▓р╕Щ - р╕Чр╕│р╣Др╕Фр╣Йр╕Фр╕╡р╕бр╕▓р╕Б!")
                elif change < -5:
                    recommendations.append(f"ЁЯУЙ р╕вр╕нр╕Фр╕Вр╕▓р╕вр╕ер╕Фр╕ер╕З {abs(change):.1f}% - р╕Юр╕гр╕╕р╣Ир╕Зр╕Щр╕╡р╣Йр╕ер╕нр╕Зр╕Чр╕│р╣Вр╕Ыр╕гр╣Вр╕бр╕Кр╕▒р╣Ир╕Щр╕Фр╕╣р╣Др╕лр╕б")
        
        if menu_analysis and menu_analysis.get('top_sellers'):
            top_item = menu_analysis['top_sellers'][0]
            recommendations.append(f"ЁЯПЖ р╣Ар╕бр╕Щр╕╣р╕Вр╕▓р╕вр╕Фр╕╡р╕Чр╕╡р╣Ир╕кр╕╕р╕Фр╕зр╕▒р╕Щр╕Щр╕╡р╣Й: '{top_item['menu_name']}' р╕Вр╕▓р╕вр╣Др╕Фр╣Й {top_item['total_sold']} р╕гр╕▓р╕вр╕Бр╕▓р╕г")
        
        if ingredient_recommendations and ingredient_recommendations.get('recommendations'):
            urgent_count = len([r for r in ingredient_recommendations['recommendations'] if r['shortage'] > r['current_stock']])
            if urgent_count > 0:
                recommendations.append(f"тЪая╕П р╕бр╕╡р╕зр╕▒р╕Хр╕Цр╕╕р╕Фр╕┤р╕Ъ {urgent_count} р╕гр╕▓р╕вр╕Бр╕▓р╕гр╕Чр╕╡р╣Ир╕Хр╣Йр╕нр╕Зр╕кр╕▒р╣Ир╕Зр╣Ар╕Юр╕┤р╣Ир╕бр╕Фр╣Ир╕зр╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Юр╕гр╕╕р╣Ир╕Зр╕Щр╕╡р╣Й")
        
        return recommendations
    
    def _generate_today_recommendations(self, yesterday_analysis: Dict) -> list:
        """р╕кр╕гр╣Йр╕▓р╕Зр╕Др╕│р╣Бр╕Щр╕░р╕Щр╕│р╕кр╕│р╕лр╕гр╕▒р╕Ър╕зр╕▒р╕Щр╕Щр╕╡р╣Й"""
        recommendations = []
        
        if yesterday_analysis:
            revenue = yesterday_analysis.get('total_revenue', 0)
            change = yesterday_analysis.get('revenue_change_percent', 0)
            
            if revenue > 0:
                recommendations.append(f"ЁЯУК р╣Ар╕бр╕╖р╣Ир╕нр╕зр╕▓р╕Щр╕вр╕нр╕Фр╕Вр╕▓р╕в {revenue:,.2f} р╕Ър╕▓р╕Ч")
                
                if change > 0:
                    recommendations.append("ЁЯОп р╣Ар╕бр╕╖р╣Ир╕нр╕зр╕▓р╕Щр╕вр╕нр╕Фр╕Вр╕▓р╕вр╕Фр╕╡ р╕зр╕▒р╕Щр╕Щр╕╡р╣Йр╕Юр╕вр╕▓р╕вр╕▓р╕бр╕гр╕▒р╕Бр╕йр╕▓р╕гр╕░р╕Фр╕▒р╕Ър╕Щр╕╡р╣Йр╣Др╕зр╣Й")
                else:
                    recommendations.append("ЁЯТк р╕зр╕▒р╕Щр╕Щр╕╡р╣Йр╣Ар╕Ыр╣Зр╕Щр╣Вр╕нр╕Бр╕▓р╕кр╕Фр╕╡р╕Чр╕╡р╣Ир╕Ир╕░р╕Чр╕│р╕вр╕нр╕Фр╕Вр╕▓р╕вр╣Гр╕лр╣Йр╕Фр╕╡р╕Бр╕зр╣Ир╕▓р╣Ар╕бр╕╖р╣Ир╕нр╕зр╕▓р╕Щ")
        
        # р╕Др╕│р╣Бр╕Щр╕░р╕Щр╕│р╕Чр╕▒р╣Ир╕зр╣Др╕Ы
        weekday = datetime.now().weekday()
        if weekday in [5, 6]:  # р╕зр╕▒р╕Щр╣Ар╕кр╕▓р╕гр╣М-р╕нр╕▓р╕Чр╕┤р╕Хр╕вр╣М
            recommendations.append("ЁЯОЙ р╕зр╕▒р╕Щр╕лр╕вр╕╕р╕Фр╕бр╕▒р╕Бр╕бр╕╡р╕ер╕╣р╕Бр╕Др╣Йр╕▓р╣Ар╕вр╕нр╕░ р╣Ар╕Хр╕гр╕╡р╕вр╕бр╕Юр╕гр╣Йр╕нр╕бр╕гр╕▒р╕Ър╕нр╕нр╕гр╣Мр╣Ар╕Фр╕нр╕гр╣Мр╣Ар╕вр╕нр╕░р╣Ж")
        elif weekday == 0:  # р╕зр╕▒р╕Щр╕Ир╕▒р╕Щр╕Чр╕гр╣М
            recommendations.append("тШХ р╕зр╕▒р╕Щр╕Ир╕▒р╕Щр╕Чр╕гр╣Мр╕Др╕Щр╕бр╕▒р╕Бр╕Фр╕╖р╣Ир╕бр╕Бр╕▓р╣Бр╕Яр╣Ар╕вр╕нр╕░ р╣Ар╕Хр╕гр╕╡р╕вр╕бр╣Ар╕Др╕гр╕╖р╣Ир╕нр╕Зр╕Фр╕╖р╣Ир╕бр╣Гр╕лр╣Йр╕Юр╕гр╣Йр╕нр╕б")
        
        return recommendations
    
    def _is_store_open(self, store_id: int) -> bool:
        """р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕зр╣Ир╕▓р╕гр╣Йр╕▓р╕Щр╣Ар╕Ыр╕┤р╕Фр╕нр╕вр╕╣р╣Ир╕лр╕гр╕╖р╕нр╣Др╕бр╣И"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT is_open FROM stores WHERE id = ?
            """, (store_id,))
            
            result = cursor.fetchone()
            conn.close()
            
            return result[0] if result else False
            
        except Exception as e:
            self.logger.error(f"Error checking store status: {e}")
            return False
    
    def _close_store(self, store_id: int, auto_close: bool = False) -> bool:
        """р╕Ыр╕┤р╕Фр╕гр╣Йр╕▓р╕Щ"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("""
                UPDATE stores 
                SET is_open = 0, 
                    last_closed_at = ?,
                    auto_closed = ?
                WHERE id = ?
            """, (datetime.now().isoformat(), auto_close, store_id))
            
            conn.commit()
            conn.close()
            
            return True
            
        except Exception as e:
            self.logger.error(f"Error closing store: {e}")
            return False
    
    def _save_auto_close_setting(self, store_id: int, close_time: str, enabled: bool):
        """р╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕Бр╕▓р╕гр╕Хр╕▒р╣Йр╕Зр╕Др╣Ир╕▓р╕Ыр╕┤р╕Фр╕гр╣Йр╕▓р╕Щр╕нр╕▒р╕Хр╣Вр╕Щр╕бр╕▒р╕Хр╕┤"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("""
                INSERT OR REPLACE INTO auto_close_settings 
                (store_id, close_time, enabled, updated_at)
                VALUES (?, ?, ?, ?)
            """, (store_id, close_time, enabled, datetime.now().isoformat()))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            self.logger.error(f"Error saving auto close setting: {e}")
    
    def _save_daily_summary(self, store_id: int, summary: Dict):
        """р╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕кр╕гр╕╕р╕Ыр╕вр╕нр╕Фр╕Вр╕▓р╕вр╕гр╕▓р╕вр╕зр╕▒р╕Щ"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("""
                INSERT OR REPLACE INTO daily_summaries 
                (store_id, date, summary_data, created_at)
                VALUES (?, ?, ?, ?)
            """, (
                store_id, 
                summary.get('date'), 
                json.dumps(summary, ensure_ascii=False),
                datetime.now().isoformat()
            ))
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            self.logger.error(f"Error saving daily summary: {e}")
    
    def get_auto_close_settings(self, store_id: int) -> Dict:
        """р╕Фр╕╢р╕Зр╕Бр╕▓р╕гр╕Хр╕▒р╣Йр╕Зр╕Др╣Ир╕▓р╕Ыр╕┤р╕Фр╕гр╣Йр╕▓р╕Щр╕нр╕▒р╕Хр╣Вр╕Щр╕бр╕▒р╕Хр╕┤"""
        try:
            return self.auto_close_settings.get(store_id, {
                'close_time': '22:00',
                'enabled': False,
                'updated_at': None
            })
            
        except Exception as e:
            self.logger.error(f"Error getting auto close settings: {e}")
            return {}
    
    def load_auto_close_settings(self):
        """р╣Вр╕лр╕ер╕Фр╕Бр╕▓р╕гр╕Хр╕▒р╣Йр╕Зр╕Др╣Ир╕▓р╕Ыр╕┤р╕Фр╕гр╣Йр╕▓р╕Щр╕нр╕▒р╕Хр╣Вр╕Щр╕бр╕▒р╕Хр╕┤р╕Ир╕▓р╕Бр╕Рр╕▓р╕Щр╕Вр╣Йр╕нр╕бр╕╣р╕е"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT store_id, close_time, enabled, updated_at 
                FROM auto_close_settings 
                WHERE enabled = 1
            """)
            
            settings = cursor.fetchall()
            conn.close()
            
            for setting in settings:
                store_id, close_time, enabled, updated_at = setting
                self.set_auto_close_time(store_id, close_time, enabled)
            
            self.logger.info(f"Loaded {len(settings)} auto close settings")
            
        except Exception as e:
            self.logger.error(f"Error loading auto close settings: {e}")

# р╕кр╕гр╣Йр╕▓р╕З instance global
auto_store_manager = AutoStoreManager()

